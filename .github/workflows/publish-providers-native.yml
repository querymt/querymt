name: Build & Publish Native Provider Plugins

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.compute.outputs.matrix }}

    steps:
      - name: Check out full history
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Determine which native plugins need rebuilding
        id: compute
        shell: bash
        run: |
          BASE=${{ github.event.before }}
          HEAD=${{ github.sha }}

          # all subfolders under crates/providers
          mapfile -t ALL < <(find crates/providers -maxdepth 1 -mindepth 1 -type d -printf '%f\n')

          if [[ "$GITHUB_EVENT_NAME" == "workflow_dispatch" ]]; then
            PROVIDERS=( "${ALL[@]}" )
          # if this is the very first commit (BASE is all zeros), rebuild everything
          elif [[ "$BASE" == "0000000000000000000000000000000000000000" ]]; then
            PROVIDERS=( "${ALL[@]}" )
          else
            # list changed files between BASE and HEAD
            CHANGED=$(git diff --name-only $BASE $HEAD)

            PROVIDERS=()
            for f in $CHANGED; do
              # if the querymt library changed, rebuild/test all plugins
              if [[ $f =~ ^crates/querymt/ ]]; then
                PROVIDERS=( "${ALL[@]}" )
                break
              fi

              # if a provider crate changed, pick it up
              if [[ $f =~ ^crates/providers/([^/]+)/ ]]; then
                name=${BASH_REMATCH[1]}
                # de-dup
                if [[ ! " ${PROVIDERS[*]} " =~ " $name " ]]; then
                  PROVIDERS+=( "$name" )
                fi
              fi
            done
          fi

          get_provider_type() {
            local crate="$1"
            local toml="crates/providers/$crate/Cargo.toml"
            local detected_type=""
            if [[ -f "$toml" ]]; then
              detected_type=$(
                awk -F'=' '
                  $0 ~ /^\[package\.metadata\.qmt\]/ {in_qmt=1; next}
                  in_qmt && $0 ~ /^\[/ {in_qmt=0}
                  in_qmt {
                    key=$1
                    gsub(/^[ \t]+|[ \t]+$/, "", key)
                    if (key == "type") {
                      gsub(/"/, "", $2); gsub(/ /, "", $2); print $2; exit
                    }
                  }
                ' "$toml"
              )
            fi
            echo "$detected_type"
          }

          NATIVE=()
          for p in "${PROVIDERS[@]}"; do
            if [[ "$(get_provider_type "$p")" == "native" ]]; then
              NATIVE+=( "$p" )
            fi
          done

          if [ ${#NATIVE[@]} -eq 0 ]; then
            NATIVE=( "noop" )
          fi

          echo "Final native plugin list: ${NATIVE[*]}"

          matrix=$(PROVIDERS="${NATIVE[*]}" NATIVE_MATRIX=".github/native-matrix.yml" python - <<'PY'
          import json
          import os
          import re
          import subprocess
          import sys

          def load_yaml(path):
            try:
              import yaml
            except Exception:
              subprocess.check_call([sys.executable, "-m", "pip", "install", "--user", "pyyaml"])
              import yaml
            with open(path, "r", encoding="utf-8") as f:
              return yaml.safe_load(f) or {}

          def runner_for(osname):
            return {
              "linux": "ubuntu-latest",
              "darwin": "macos-14",
              "windows": "windows-latest",
            }[osname]

          def sanitize_feature_tag(feature_set):
            if not feature_set:
              return "default"
            return re.sub(r"[^A-Za-z0-9._-]+", "-", feature_set).strip("-")

          providers = [p for p in os.environ.get("PROVIDERS", "").split() if p]
          if not providers or providers == ["noop"]:
            print(json.dumps({"include": [{"crate": "noop", "runner": "ubuntu-latest", "env": {}}]}))
            raise SystemExit(0)

          config = load_yaml(os.environ.get("NATIVE_MATRIX", ".github/native-matrix.yml"))
          defaults = config.get("defaults", {}) or {}
          default_targets = defaults.get("targets", {}) or {}
          default_feature_sets = defaults.get("feature_sets", {}) or {}
          providers_conf = config.get("providers", {}) or {}

          entries = []
          for provider in providers:
            conf = providers_conf.get(provider, {}) or {}
            provider_targets = conf.get("targets", {}) or {}
            provider_feature_sets = conf.get("feature_sets", {}) or {}
            provider_env = conf.get("env", {}) or {}
            for osname in ("linux", "darwin", "windows"):
              targets = provider_targets.get(osname) or default_targets.get(osname) or []
              feature_sets = provider_feature_sets.get(osname) or default_feature_sets.get(osname) or []
              if not targets:
                continue
              env_by_feature = provider_env.get(osname) or {}
              for target_info in targets:
                target = target_info.get("target")
                arch = target_info.get("arch")
                if not target or not arch:
                  continue
                # Check if this target has per-arch features, otherwise use OS-level features
                target_features = target_info.get("features")
                if target_features is not None:
                  # Use per-architecture feature sets
                  features_to_build = target_features
                else:
                  # Use OS-level feature sets
                  features_to_build = feature_sets

                if not features_to_build:
                  continue

                for feature_set in features_to_build:
                  features = feature_set or ""
                  feature_tag = sanitize_feature_tag(features)
                  needs_cuda = "cuda" in features.split()
                  env_vars = env_by_feature.get(features) or {}
                  entries.append({
                    "crate": provider,
                    "os": osname,
                    "arch": arch,
                    "target": target,
                    "features": features,
                    "feature_tag": feature_tag,
                    "needs_cuda": str(needs_cuda).lower(),
                    "runner": runner_for(osname),
                    "env": env_vars,
                  })

          print(json.dumps({"include": entries}))
          PY
          )
          echo "matrix=$matrix" >> $GITHUB_OUTPUT

  publish-native-plugins:
    needs: detect-changes
    runs-on: ${{ matrix.runner }}
    env: ${{ matrix.env }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}

    steps:
      - name: No crates changed
        if: matrix.crate == 'noop'
        run: echo "✅ No native plugin crates to build—skipping."

      - name: Check out code
        if: matrix.crate != 'noop'
        uses: actions/checkout@v5

      - name: Read crate version
        if: matrix.crate != 'noop'
        id: get-version
        shell: bash
        run: |
          v=$(grep '^version' crates/providers/${{ matrix.crate }}/Cargo.toml \
                | head -n1 | cut -d'"' -f2)
          echo "VERSION=$v" >> $GITHUB_ENV

      - name: Install Rust toolchain & target
        if: matrix.crate != 'noop'
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
          targets: ${{ matrix.target }}

      - name: Install cross-compilation toolchain
        if: matrix.crate != 'noop' && runner.os == 'Linux'
        uses: taiki-e/setup-cross-toolchain-action@v1
        with:
          target: ${{ matrix.target }}

      - name: Cache Cargo dependencies
        if: matrix.crate != 'noop'
        uses: swatinem/rust-cache@v2
        with:
          key: native-${{ matrix.target }}-${{ matrix.feature_tag }}

      - name: Set up CUDA toolkit
        if: matrix.crate != 'noop' && matrix.needs_cuda == 'true'
        uses: mjun0812/setup-cuda@v1
        with:
          version: "12.8"

      - name: Build native library
        if: matrix.crate != 'noop'
        shell: bash
        run: |
          FEATURES="${{ matrix.features }}"
          FEATURE_ARGS=()
          if [ -n "$FEATURES" ]; then
            FEATURE_ARGS=( --features "$FEATURES" )
          fi

          cargo build -p qmt-${{ matrix.crate }} \
            --release \
            --target ${{ matrix.target }} \
            "${FEATURE_ARGS[@]}"

      - name: Package native library
        if: matrix.crate != 'noop'
        shell: bash
        run: |
          LIB_BASE="qmt_${{ matrix.crate }}"
          case "${{ matrix.os }}" in
            linux) LIB_FILE="lib${LIB_BASE}.so" ;;
            darwin) LIB_FILE="lib${LIB_BASE}.dylib" ;;
            windows) LIB_FILE="${LIB_BASE}.dll" ;;
          esac

          mkdir -p dist
          tar -czf dist/plugin.tar.gz -C "target/${{ matrix.target }}/release" "$LIB_FILE"
          echo "PLUGIN_TAR=dist/plugin.tar.gz" >> $GITHUB_ENV

      - name: Install Oras CLI
        if: matrix.crate != 'noop'
        uses: oras-project/setup-oras@v1

      - name: Log in to GHCR
        if: matrix.crate != 'noop'
        shell: bash
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | oras login ghcr.io \
            --username "${{ github.actor }}" \
            --password-stdin

      - name: Create OCI config file
        if: matrix.crate != 'noop'
        shell: bash
        run: echo '{}' > oci-config.json

      - name: Push native artifact to GHCR with Oras
        if: matrix.crate != 'noop'
        shell: bash
        run: |
          IMAGE_BASE="ghcr.io/${{ github.repository_owner }}/${{ matrix.crate }}"
          VERSIONED="${{ env.VERSION }}-${{ matrix.os }}-${{ matrix.arch }}-${{ matrix.feature_tag }}"
          ALIAS="${{ matrix.os }}-${{ matrix.arch }}-${{ matrix.feature_tag }}"

          echo "Pushing native artifact to ${IMAGE_BASE} with tags ${VERSIONED} and ${ALIAS}"

          oras push "${IMAGE_BASE}:${VERSIONED},${ALIAS}" \
            --config oci-config.json:application/vnd.oci.image.config.v1+json \
            --annotation "mt.query.plugin.type=native" \
            --annotation "mt.query.plugin.feature=${{ matrix.feature_tag }}" \
            --annotation "org.opencontainers.image.version=${{ env.VERSION }}" \
            --annotation "org.opencontainers.image.os=${{ matrix.os }}" \
            --annotation "org.opencontainers.image.architecture=${{ matrix.arch }}" \
            ${PLUGIN_TAR}:application/vnd.oci.image.layer.v1.tar+gzip

      - name: Save manifest data for aggregation
        if: matrix.crate != 'noop'
        shell: bash
        run: |
          IMAGE_BASE="ghcr.io/${{ github.repository_owner }}/${{ matrix.crate }}"
          VERSIONED="${{ env.VERSION }}-${{ matrix.os }}-${{ matrix.arch }}-${{ matrix.feature_tag }}"

          mkdir -p manifest-data
          cat > manifest-data/data.txt <<EOF
          PROVIDER=${{ matrix.crate }}
          VERSION=${{ env.VERSION }}
          OS=${{ matrix.os }}
          ARCH=${{ matrix.arch }}
          FEATURE_TAG=${{ matrix.feature_tag }}
          IMAGE_REF=${IMAGE_BASE}:${VERSIONED}
          EOF

      - name: Upload manifest data artifact
        if: matrix.crate != 'noop'
        uses: actions/upload-artifact@v4
        with:
          name: manifest-${{ matrix.crate }}-${{ matrix.os }}-${{ matrix.arch }}-${{ matrix.feature_tag }}
          path: manifest-data/data.txt
          retention-days: 1

  create-multi-platform-manifests:
    needs: publish-native-plugins
    runs-on: ubuntu-latest
    if: needs.publish-native-plugins.result == 'success'

    steps:
      - name: Download all manifest artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: manifest-*
          path: manifests/

      - name: Install ORAS CLI
        uses: oras-project/setup-oras@v1

      - name: Log in to GHCR
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | oras login ghcr.io \
            --username "${{ github.actor }}" \
            --password-stdin

      - name: Create multi-platform manifests
        shell: bash
        run: |
          python3 <<'PYTHON'
          import os
          import subprocess
          from pathlib import Path
          from collections import defaultdict

          # Read all manifest data files
          builds = []
          manifest_dir = Path("manifests")

          if not manifest_dir.exists():
              print("No manifest data found, skipping multi-platform manifest creation")
              exit(0)

          for manifest_file in manifest_dir.rglob("data.txt"):
              data = {}
              with open(manifest_file) as f:
                  for line in f:
                      line = line.strip()
                      if "=" in line:
                          key, value = line.split("=", 1)
                          data[key] = value
              if data and data.get("PROVIDER") != "noop":
                  builds.append(data)

          if not builds:
              print("No builds to aggregate, skipping")
              exit(0)

          print(f"Found {len(builds)} builds to aggregate")
          for build in builds:
              print(f"  - {build['PROVIDER']} {build['VERSION']} {build['OS']}/{build['ARCH']} {build['FEATURE_TAG']}")

          # Group by (provider, feature_tag)
          groups = defaultdict(list)
          for build in builds:
              provider = build["PROVIDER"]
              feature_tag = build["FEATURE_TAG"]
              key = (provider, feature_tag)
              groups[key].append(build)

          print(f"\nGrouped into {len(groups)} unique (provider, feature_tag) combinations")

          # Track which providers we've seen for creating plain "latest" tag
          providers_versions = {}

          # Create manifest indexes for each group
          for (provider, feature_tag), images in groups.items():
              base = f"ghcr.io/${{ github.repository_owner }}/{provider}"

              # Extract version from first image (all should have same version)
              version = images[0]["VERSION"]

              # Track provider version
              if provider not in providers_versions:
                  providers_versions[provider] = version

              # Collect all image refs
              refs = [img["IMAGE_REF"] for img in images]

              print(f"\n=== Processing {provider}:{feature_tag} ===")
              print(f"  Version: {version}")
              print(f"  Platforms: {len(images)}")
              for img in images:
                  print(f"    - {img['OS']}/{img['ARCH']} -> {img['IMAGE_REF']}")

              # 1. Create version-pinned multi-platform manifest (e.g., 0.1.0-metal)
              versioned_tag = f"{base}:{version}-{feature_tag}"
              cmd = ["oras", "manifest", "index", "create", versioned_tag]
              for ref in refs:
                  cmd.extend(["--amend", ref])

              print(f"  Creating: {versioned_tag}")
              result = subprocess.run(cmd, capture_output=True, text=True)
              if result.returncode != 0:
                  print(f"    ERROR: {result.stderr}")
                  exit(1)
              else:
                  print(f"    ✓ Success")

              # 2. Create/update latest-{feature} tag (e.g., latest-metal)
              latest_feature_tag = f"{base}:latest-{feature_tag}"
              cmd = ["oras", "manifest", "index", "create", latest_feature_tag]
              for ref in refs:
                  cmd.extend(["--amend", ref])

              print(f"  Creating: {latest_feature_tag}")
              result = subprocess.run(cmd, capture_output=True, text=True)
              if result.returncode != 0:
                  print(f"    ERROR: {result.stderr}")
                  exit(1)
              else:
                  print(f"    ✓ Success")

              # 3. For "default" feature, also create plain version tag (e.g., 0.1.0)
              if feature_tag == "default":
                  plain_version_tag = f"{base}:{version}"
                  cmd = ["oras", "manifest", "index", "create", plain_version_tag]
                  for ref in refs:
                      cmd.extend(["--amend", ref])

                  print(f"  Creating: {plain_version_tag}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  if result.returncode != 0:
                      print(f"    ERROR: {result.stderr}")
                      exit(1)
                  else:
                      print(f"    ✓ Success")

          # 4. Create plain "latest" tag for each provider (points to default features)
          print(f"\n=== Creating 'latest' tags ===")
          for provider, version in providers_versions.items():
              # Check if this provider has a "default" feature set
              default_key = (provider, "default")
              if default_key in groups:
                  base = f"ghcr.io/${{ github.repository_owner }}/{provider}"
                  refs = [img["IMAGE_REF"] for img in groups[default_key]]

                  latest_tag = f"{base}:latest"
                  cmd = ["oras", "manifest", "index", "create", latest_tag]
                  for ref in refs:
                      cmd.extend(["--amend", ref])

                  print(f"  Creating: {latest_tag}")
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  if result.returncode != 0:
                      print(f"    ERROR: {result.stderr}")
                      exit(1)
                  else:
                      print(f"    ✓ Success")
              else:
                  print(f"  Skipping {provider}:latest (no 'default' feature set found)")

          print(f"\n=== Summary ===")
          total_manifests = len(groups) * 2  # version-pinned + latest-feature
          total_manifests += sum(1 for (_, ft) in groups.keys() if ft == "default")  # plain version tags
          total_manifests += len([p for p in providers_versions if (p, "default") in groups])  # latest tags
          print(f"Created {total_manifests} manifest indexes across {len(providers_versions)} provider(s)")
          PYTHON
