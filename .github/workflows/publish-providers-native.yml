name: Build & Publish Native Provider Plugins

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.compute.outputs.matrix }}

    steps:
      - name: Check out full history
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Determine which native plugins need rebuilding
        id: compute
        shell: bash
        run: |
          BASE=${{ github.event.before }}
          HEAD=${{ github.sha }}

          # all subfolders under crates/providers
          mapfile -t ALL < <(find crates/providers -maxdepth 1 -mindepth 1 -type d -printf '%f\n')

          if [[ "$GITHUB_EVENT_NAME" == "workflow_dispatch" ]]; then
            PROVIDERS=( "${ALL[@]}" )
          # if this is the very first commit (BASE is all zeros), rebuild everything
          elif [[ "$BASE" == "0000000000000000000000000000000000000000" ]]; then
            PROVIDERS=( "${ALL[@]}" )
          else
            # list changed files between BASE and HEAD
            CHANGED=$(git diff --name-only $BASE $HEAD)

            PROVIDERS=()
            for f in $CHANGED; do
              # if the querymt library changed, rebuild/test all plugins
              if [[ $f =~ ^crates/querymt/ ]]; then
                PROVIDERS=( "${ALL[@]}" )
                break
              fi

              # if a provider crate changed, pick it up
              if [[ $f =~ ^crates/providers/([^/]+)/ ]]; then
                name=${BASH_REMATCH[1]}
                # de-dup
                if [[ ! " ${PROVIDERS[*]} " =~ " $name " ]]; then
                  PROVIDERS+=( "$name" )
                fi
              fi
            done
          fi

          get_provider_type() {
            local crate="$1"
            local toml="crates/providers/$crate/Cargo.toml"
            local detected_type=""
            if [[ -f "$toml" ]]; then
              detected_type=$(
                awk -F'=' '
                  $0 ~ /^\[package\.metadata\.qmt\]/ {in_qmt=1; next}
                  in_qmt && $0 ~ /^\[/ {in_qmt=0}
                  in_qmt {
                    key=$1
                    gsub(/^[ \t]+|[ \t]+$/, "", key)
                    if (key == "type") {
                      gsub(/"/, "", $2); gsub(/ /, "", $2); print $2; exit
                    }
                  }
                ' "$toml"
              )
            fi
            echo "$detected_type"
          }

          NATIVE=()
          for p in "${PROVIDERS[@]}"; do
            if [[ "$(get_provider_type "$p")" == "native" ]]; then
              NATIVE+=( "$p" )
            fi
          done

          if [ ${#NATIVE[@]} -eq 0 ]; then
            NATIVE=( "noop" )
          fi

          echo "Final native plugin list: ${NATIVE[*]}"

          matrix=$(PROVIDERS="${NATIVE[*]}" NATIVE_MATRIX=".github/native-matrix.yml" python - <<'PY'
          import json
          import os
          import re
          import subprocess
          import sys

          def load_yaml(path):
            try:
              import yaml
            except Exception:
              subprocess.check_call([sys.executable, "-m", "pip", "install", "--user", "pyyaml"])
              import yaml
            with open(path, "r", encoding="utf-8") as f:
              return yaml.safe_load(f) or {}

          def runner_for(osname):
            return {
              "linux": "ubuntu-latest",
              "darwin": "macos-latest",
              "windows": "windows-latest",
            }[osname]

          def get_runner_for_build(target_info, osname, is_cuda):
            """Get appropriate runner based on target and whether it's a CUDA build"""
            if is_cuda and 'runner_cuda' in target_info:
              return target_info['runner_cuda']
            if 'runner' in target_info:
              return target_info['runner']
            return runner_for(osname)

          def sanitize_feature_tag(feature_set):
            if not feature_set:
              return "default"
            return re.sub(r"[^A-Za-z0-9._-]+", "-", feature_set).strip("-")

          def generate_cuda_features(cuda_config, arch_key):
            """Generate CUDA feature sets for a specific architecture"""
            if not cuda_config or 'variants' not in cuda_config:
              return []
            variants = cuda_config.get('variants', {}).get(arch_key, [])
            if not variants:
              return []
            cuda_version = cuda_config.get('toolkit_version', '12.8')
            strategy = cuda_config.get('strategy', 'split')
            
            if strategy == 'combined':
              sm_list = [str(v['sm']) for v in variants]
              # For combined, we need to merge all features from all variants
              all_features = set()
              for v in variants:
                all_features.update(v.get('features', ['cuda']))
              
              feature_string = " ".join(sorted(list(all_features)))
              feature_name = f"cuda{cuda_version}"
              return [{
                'feature_string': feature_string,
                'feature_tag': sanitize_feature_tag(feature_name),
                'compute_cap': ";".join(sm_list),
                'cuda_version': cuda_version
              }]
            else:
              features = []
              for variant in variants:
                sm = variant['sm']
                # Use features from variant or default to ["cuda"]
                variant_features = variant.get('features', ['cuda'])
                feature_string = " ".join(variant_features)
                feature_name = f"cuda{cuda_version}-sm{sm}"
                features.append({
                  'feature_string': feature_string,
                  'feature_tag': sanitize_feature_tag(feature_name),
                  'compute_cap': str(sm),
                  'cuda_version': cuda_version
                })
              return features

          providers = [p for p in os.environ.get("PROVIDERS", "").split() if p]
          if not providers or providers == ["noop"]:
            print(json.dumps({"include": [{"crate": "noop", "runner": "ubuntu-latest", "env": {}}]}))
            raise SystemExit(0)

          config = load_yaml(os.environ.get("NATIVE_MATRIX", ".github/native-matrix.yml"))
          defaults = config.get("defaults", {}) or {}
          default_targets = defaults.get("targets", {}) or {}
          default_feature_sets = defaults.get("feature_sets", {}) or {}
          providers_conf = config.get("providers", {}) or {}

          entries = []
          for provider in providers:
            conf = providers_conf.get(provider, {}) or {}
            provider_targets = conf.get("targets", {}) or {}
            provider_feature_sets = conf.get("feature_sets", {}) or {}
            provider_env = conf.get("env", {}) or {}
            cuda_config = conf.get("cuda", {})
            for osname in ("linux", "darwin", "windows"):
              # Check for explicit override (even if empty list) before falling back to defaults
              if osname in provider_targets:
                targets = provider_targets.get(osname) or []
              else:
                targets = default_targets.get(osname) or []
              if not targets:
                continue
              env_by_feature = provider_env.get(osname) or {}
              for target_info in targets:
                target = target_info.get("target")
                arch = target_info.get("arch")
                if not target or not arch:
                  continue
                
                arch_key = 'x86_64' if arch == 'amd64' else 'aarch64'
                
                # Check if this target has per-arch features, otherwise use OS-level features
                target_features = target_info.get("features")
                if target_features is not None:
                  features_to_build = target_features
                else:
                  features_to_build = provider_feature_sets.get(osname) or default_feature_sets.get(osname) or []
                
                # Process non-CUDA features
                for feature_set in features_to_build:
                  if feature_set:
                    features = feature_set
                    feature_tag = sanitize_feature_tag(features)
                    runner = get_runner_for_build(target_info, osname, is_cuda=False)
                    entries.append({
                      "crate": provider,
                      "os": osname,
                      "arch": arch,
                      "target": target,
                      "features": features,
                      "feature_tag": feature_tag,
                      "needs_cuda": "false",
                      "runner": runner,
                      "env": env_by_feature.get(features) or {},
                    })
                
                # Process default (empty string) feature
                if "" in features_to_build or not features_to_build:
                  runner = get_runner_for_build(target_info, osname, is_cuda=False)
                  entries.append({
                    "crate": provider,
                    "os": osname,
                    "arch": arch,
                    "target": target,
                    "features": "",
                    "feature_tag": "default",
                    "needs_cuda": "false",
                    "runner": runner,
                    "env": env_by_feature.get("") or {},
                  })
                
                # Add CUDA variants
                include_cuda = False
                # Disable Windows CUDA builds until upstream support lands.
                # TODO: retest after https://github.com/EricLBuehler/mistral.rs/pull/1801 merged
                if osname in ['linux']:
                  # If target features are not explicitly restricted, or if they include "cuda"
                  if target_features is None:
                    include_cuda = True
                  elif any("cuda" in f for f in target_features):
                    include_cuda = True

                # Check if CUDA is explicitly disabled in config
                if include_cuda and cuda_config.get('disabled', False):
                  include_cuda = False

                if include_cuda:
                  cuda_features = generate_cuda_features(cuda_config, arch_key)
                  for cuda_feat in cuda_features:
                    runner = get_runner_for_build(target_info, osname, is_cuda=True)
                    env_vars = env_by_feature.get(cuda_feat['feature_string']) or {}
                    env_vars.update({
                      "CUDA_COMPUTE_CAP": cuda_feat['compute_cap'],
                      "CUDA_VERSION": cuda_feat['cuda_version']
                    })
                    entries.append({
                      "crate": provider,
                      "os": osname,
                      "arch": arch,
                      "target": target,
                      "features": cuda_feat['feature_string'],
                      "feature_tag": cuda_feat['feature_tag'],
                      "needs_cuda": "true",
                      "runner": runner,
                      "env": env_vars,
                    })

          print(json.dumps({"include": entries}))
          PY

          )
          echo "matrix=$matrix" >> $GITHUB_OUTPUT

  publish-native-plugins:
    needs: detect-changes
    runs-on: ${{ matrix.runner }}
    env: ${{ matrix.env }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}

    steps:
      - name: No crates changed
        if: matrix.crate == 'noop'
        run: echo "✅ No native plugin crates to build—skipping."

      - name: Check out code
        if: matrix.crate != 'noop'
        uses: actions/checkout@v5

      - name: Read crate version
        if: matrix.crate != 'noop'
        id: get-version
        shell: bash
        run: |
          v=$(grep '^version' crates/providers/${{ matrix.crate }}/Cargo.toml \
                | head -n1 | cut -d'"' -f2)
          echo "VERSION=$v" >> $GITHUB_ENV

      - name: Install Rust toolchain & target
        if: matrix.crate != 'noop'
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
          targets: ${{ matrix.target }}

      - name: Install cross-compilation toolchain
        if: matrix.crate != 'noop' && runner.os == 'Linux'
        uses: taiki-e/setup-cross-toolchain-action@v1
        with:
          target: ${{ matrix.target }}

      - name: Cache Cargo dependencies
        if: matrix.crate != 'noop'
        uses: swatinem/rust-cache@v2
        with:
          key: native-${{ matrix.target }}-${{ matrix.feature_tag }}
          cache-targets: "false"

      - name: Set up CUDA toolkit
        if: matrix.crate != 'noop' && matrix.needs_cuda == 'true'
        uses: mjun0812/setup-cuda@v1
        with:
          version: "${{ matrix.env.CUDA_VERSION || '12.8' }}"

      - name: Install cuDNN (Linux)
        if: matrix.os == 'linux' && matrix.needs_cuda == 'true'
        run: |
          sudo apt-get update
          sudo apt-get install -y libcudnn9-dev-cuda-12

      - name: Install cuDNN (Windows)
        if: matrix.os == 'windows' && matrix.needs_cuda == 'true'
        shell: powershell
        run: |
          $url = "https://developer.download.nvidia.com/compute/cudnn/redist/cudnn/windows-x86_64/cudnn-windows-x86_64-9.0.0.312_cuda12-archive.zip"
          Invoke-WebRequest -Uri $url -OutFile cudnn.zip
          Expand-Archive cudnn.zip -DestinationPath .
          $folder = Get-ChildItem -Directory -Filter "cudnn-windows-x86_64-9*" | Select-Object -First 1
          Copy-Item -Path "$($folder.FullName)\bin\*" -Destination "$env:CUDA_PATH\bin" -Recurse -Force
          Copy-Item -Path "$($folder.FullName)\include\*" -Destination "$env:CUDA_PATH\include" -Recurse -Force
          Copy-Item -Path "$($folder.FullName)\lib\x64\*" -Destination "$env:CUDA_PATH\lib\x64" -Recurse -Force

      - name: Set up MSVC (Windows CUDA)
        if: matrix.os == 'windows' && matrix.needs_cuda == 'true'
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x64

      - name: Build native library
        if: matrix.crate != 'noop'
        shell: bash
        env: ${{ matrix.env }}
        run: |
          if [[ "${{ matrix.os }}" == "windows" ]]; then
            # Remove Git's link.exe to prevent it from shadowing MSVC's linker.
            # This is a known issue when using bash on Windows GHA runners.
            rm -f /usr/bin/link.exe
          fi

          FEATURES="${{ matrix.features }}"
          FEATURE_ARGS=()
          if [ -n "$FEATURES" ]; then
            FEATURE_ARGS=( --features "$FEATURES" )
          fi

          cargo build -p qmt-${{ matrix.crate }} \
            --release \
            --target ${{ matrix.target }} \
            "${FEATURE_ARGS[@]}"

      - name: Package native library
        if: matrix.crate != 'noop'
        shell: bash
        run: |
          LIB_BASE="qmt_${{ matrix.crate }}"
          case "${{ matrix.os }}" in
            linux) LIB_FILE="lib${LIB_BASE}.so" ;;
            darwin) LIB_FILE="lib${LIB_BASE}.dylib" ;;
            windows) LIB_FILE="${LIB_BASE}.dll" ;;
          esac

          mkdir -p dist
          tar -czf dist/plugin.tar.gz -C "target/${{ matrix.target }}/release" "$LIB_FILE"
          echo "PLUGIN_TAR=dist/plugin.tar.gz" >> $GITHUB_ENV

      - name: Cleanup build artifacts (non-Windows)
        if: matrix.crate != 'noop' && matrix.os != 'windows'
        shell: bash
        run: |
          # Free runner disk before cache post-job runs.
          rm -rf target

      - name: Cleanup build artifacts (Windows)
        if: matrix.crate != 'noop' && matrix.os == 'windows'
        shell: powershell
        run: |
          # Free runner disk before cache post-job runs.
          Remove-Item -Recurse -Force target

      - name: Install Oras CLI
        if: matrix.crate != 'noop'
        uses: oras-project/setup-oras@v1

      - name: Log in to GHCR
        if: matrix.crate != 'noop'
        shell: bash
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | oras login ghcr.io \
            --username "${{ github.actor }}" \
            --password-stdin

      - name: Create OCI config file
        if: matrix.crate != 'noop'
        shell: bash
        run: echo '{}' > oci-config.json

      - name: Push native artifact to GHCR with Oras
        if: matrix.crate != 'noop'
        shell: bash
        run: |
          IMAGE_BASE="ghcr.io/${{ github.repository_owner }}/${{ matrix.crate }}"
          VERSIONED="${{ env.VERSION }}-${{ matrix.os }}-${{ matrix.arch }}-${{ matrix.feature_tag }}"
          ALIAS="${{ matrix.os }}-${{ matrix.arch }}-${{ matrix.feature_tag }}"

          echo "Pushing native artifact to ${IMAGE_BASE} with tags ${VERSIONED} and ${ALIAS}"

          oras push "${IMAGE_BASE}:${VERSIONED},${ALIAS}" \
            --config oci-config.json:application/vnd.oci.image.config.v1+json \
            --annotation "mt.query.plugin.type=native" \
            --annotation "mt.query.plugin.feature=${{ matrix.feature_tag }}" \
            --annotation "org.opencontainers.image.version=${{ env.VERSION }}" \
            --annotation "org.opencontainers.image.os=${{ matrix.os }}" \
            --annotation "org.opencontainers.image.architecture=${{ matrix.arch }}" \
            ${PLUGIN_TAR}:application/vnd.oci.image.layer.v1.tar+gzip

      - name: Save manifest data for aggregation
        if: matrix.crate != 'noop'
        shell: bash
        run: |
          IMAGE_BASE="ghcr.io/${{ github.repository_owner }}/${{ matrix.crate }}"
          VERSIONED="${{ env.VERSION }}-${{ matrix.os }}-${{ matrix.arch }}-${{ matrix.feature_tag }}"

          mkdir -p manifest-data
          cat > manifest-data/data.txt <<EOF
          PROVIDER=${{ matrix.crate }}
          VERSION=${{ env.VERSION }}
          OS=${{ matrix.os }}
          ARCH=${{ matrix.arch }}
          FEATURE_TAG=${{ matrix.feature_tag }}
          IMAGE_REF=${IMAGE_BASE}:${VERSIONED}
          EOF

      - name: Upload manifest data artifact
        if: matrix.crate != 'noop'
        uses: actions/upload-artifact@v4
        with:
          name: manifest-${{ matrix.crate }}-${{ matrix.os }}-${{ matrix.arch }}-${{ matrix.feature_tag }}
          path: manifest-data/data.txt
          retention-days: 1

  create-multi-platform-manifests:
    needs: publish-native-plugins
    runs-on: ubuntu-latest
    if: needs.publish-native-plugins.result == 'success'

    steps:
      - name: Download all manifest artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: manifest-*
          path: manifests/
          merge-multiple: false

      - name: Debug - List downloaded artifacts
        shell: bash
        run: |
          echo "=== Downloaded Artifact Structure ==="
          ls -la manifests/ || echo "No manifests directory found"
          echo ""
          echo "=== Found data.txt files ==="
          find manifests/ -type f -name "data.txt" -exec echo "  - {}" \;
          echo ""
          echo "=== Artifact contents ==="
          for data_file in manifests/*/data.txt; do
            [[ -f "$data_file" ]] || continue
            echo "File: $data_file"
            cat "$data_file"
            echo "---"
          done

      - name: Wait for GHCR to index manifests
        shell: bash
        run: |
          echo "Waiting 15 seconds for GHCR to fully index uploaded manifests..."
          sleep 15
          echo "✓ Wait complete"

      - name: Install ORAS CLI
        uses: oras-project/setup-oras@v1

      - name: Log in to GHCR
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | oras login ghcr.io \
            --username "${{ github.actor }}" \
            --password-stdin

      - name: Create multi-platform manifests
        shell: bash
        run: |
          #!/bin/bash
          set -euo pipefail

          echo "=== Creating multi-platform manifests with proper platform fields ==="
          
          # Check if we have any manifest data
          if [[ ! -d "manifests" ]]; then
            echo "No manifest data found, skipping multi-platform manifest creation"
            exit 0
          fi

          # Read all manifest data files into an associative array
          declare -A builds_data
          build_count=0

          for data_file in manifests/*/data.txt; do
            [[ -f "$data_file" ]] || continue
            
            # Read the data file
            unset PROVIDER VERSION OS ARCH FEATURE_TAG IMAGE_REF
            source "$data_file"
            
            # Skip noop entries
            [[ "$PROVIDER" == "noop" ]] && continue
            
            # Store build info
            key="${PROVIDER}|${VERSION}|${OS}|${ARCH}|${FEATURE_TAG}"
            builds_data["$key"]="$IMAGE_REF"
            
            echo "  - $PROVIDER $VERSION $OS/$ARCH $FEATURE_TAG"
            ((build_count++))
          done

          if [[ $build_count -eq 0 ]]; then
            echo "No builds to aggregate, skipping"
            exit 0
          fi

          echo "Found $build_count builds to aggregate"
          echo ""
          
          # Debug: Show all parsed builds
          echo "=== Parsed Build Information ==="
          for key in "${!builds_data[@]}"; do
            IFS='|' read -r provider version os arch feature_tag <<< "$key"
            echo "  • $provider v$version - $os/$arch [$feature_tag]"
            echo "    → ${builds_data[$key]}"
          done
          echo ""

          # Function to create a multi-platform index with proper platform fields
          create_index() {
            local tag="$1"
            shift
            local refs=("$@")
            
            echo "  Creating index: $tag"
            
            # Build the manifests array for the index
            local manifests_json="["
            local first=true
            
            for ref in "${refs[@]}"; do
              # Fetch the manifest to get annotations and size (with retry logic)
              echo "    Fetching manifest: $ref"
              local manifest
              local max_attempts=5
              local attempt=1
              local success=false
              
              while [[ $attempt -le $max_attempts ]]; do
                manifest=$(oras manifest fetch "$ref" 2>&1)
                if [[ $? -eq 0 ]]; then
                  success=true
                  break
                fi
                
                if [[ $attempt -lt $max_attempts ]]; then
                  echo "    ⚠️  Attempt $attempt/$max_attempts failed, retrying in 10s..."
                  sleep 10
                fi
                ((attempt++))
              done
              
              if [[ "$success" != "true" ]]; then
                echo "    ❌ ERROR: Failed to fetch manifest after $max_attempts attempts"
                echo "    Reference: $ref"
                echo "    Last error: $manifest"
                return 1
              fi
              
              echo "    ✓ Manifest fetched successfully (attempt $attempt/$max_attempts)"
              
              # Extract platform info from annotations
              local os arch media_type
              os=$(echo "$manifest" | jq -r '.annotations["org.opencontainers.image.os"] // empty')
              arch=$(echo "$manifest" | jq -r '.annotations["org.opencontainers.image.architecture"] // empty')
              media_type=$(echo "$manifest" | jq -r '.mediaType // "application/vnd.oci.image.manifest.v1+json"')
              
              # Validate we got platform info
              if [[ -z "$os" ]] || [[ -z "$arch" ]]; then
                echo "    ERROR: Missing platform annotations in $ref"
                echo "           org.opencontainers.image.os: '$os'"
                echo "           org.opencontainers.image.architecture: '$arch'"
                return 1
              fi
              
              # Get the digest (with retry logic)
              local digest
              local resolve_attempts=3
              local resolve_attempt=1
              local resolve_success=false
              
              while [[ $resolve_attempt -le $resolve_attempts ]]; do
                digest=$(oras resolve "$ref" 2>&1)
                if [[ $? -eq 0 ]]; then
                  resolve_success=true
                  break
                fi
                
                if [[ $resolve_attempt -lt $resolve_attempts ]]; then
                  echo "    ⚠️  Resolve attempt $resolve_attempt/$resolve_attempts failed, retrying in 5s..."
                  sleep 5
                fi
                ((resolve_attempt++))
              done
              
              if [[ "$resolve_success" != "true" ]]; then
                echo "    ❌ ERROR: Failed to resolve digest after $resolve_attempts attempts"
                echo "    Last error: $digest"
                return 1
              fi
              
              # Get the manifest size
              local size
              size=$(echo "$manifest" | wc -c | tr -d ' ')
              
              echo "      Platform: $os/$arch (digest: ${digest:0:19}..., size: $size)"
              
              # Build manifest descriptor JSON
              [[ "$first" == "false" ]] && manifests_json+=","
              first=false
              
              manifests_json+=$(jq -n \
                --arg mediaType "$media_type" \
                --arg digest "$digest" \
                --argjson size "$size" \
                --arg os "$os" \
                --arg arch "$arch" \
                '{
                  mediaType: $mediaType,
                  digest: $digest,
                  size: $size,
                  platform: {
                    os: $os,
                    architecture: $arch
                  }
                }')
            done
            
            manifests_json+="]"
            
            # Create the index JSON
            local index_json
            index_json=$(jq -n \
              --argjson manifests "$manifests_json" \
              '{
                schemaVersion: 2,
                mediaType: "application/vnd.oci.image.index.v1+json",
                manifests: $manifests
              }')
            
            # Save to temp file
            local index_file
            index_file=$(mktemp)
            echo "$index_json" > "$index_file"
            
            # Push the index manifest (with retry logic)
            local push_attempts=3
            local push_attempt=1
            local push_success=false
            local push_output
            
            while [[ $push_attempt -le $push_attempts ]]; do
              push_output=$(oras manifest push "$tag" "$index_file" 2>&1)
              if [[ $? -eq 0 ]]; then
                push_success=true
                break
              fi
              
              if [[ $push_attempt -lt $push_attempts ]]; then
                echo "    ⚠️  Push attempt $push_attempt/$push_attempts failed, retrying in 5s..."
                sleep 5
              fi
              ((push_attempt++))
            done
            
            if [[ "$push_success" != "true" ]]; then
              echo "    ❌ ERROR: Failed to push index after $push_attempts attempts"
              echo "    Last error: $push_output"
              rm -f "$index_file"
              return 1
            fi
            
            rm -f "$index_file"
            echo "    ✓ Index pushed successfully"
            return 0
          }

          # Group builds by (provider, feature_tag)
          declare -A groups
          declare -A provider_versions
          
          for key in "${!builds_data[@]}"; do
            IFS='|' read -r provider version os arch feature_tag <<< "$key"
            
            group_key="${provider}|${feature_tag}"
            if [[ -z "${groups[$group_key]:-}" ]]; then
              groups[$group_key]="${builds_data[$key]}"
            else
              groups[$group_key]+=" ${builds_data[$key]}"
            fi
            
            # Track provider versions
            provider_versions[$provider]="$version"
          done

          echo "Grouped into ${#groups[@]} unique (provider, feature_tag) combinations"
          echo ""

          # Process each group
          for group_key in "${!groups[@]}"; do
            IFS='|' read -r provider feature_tag <<< "$group_key"
            IFS=' ' read -ra refs <<< "${groups[$group_key]}"
            
            base="ghcr.io/${{ github.repository_owner }}/${provider}"
            version="${provider_versions[$provider]}"
            
            echo "=== Processing ${provider}:${feature_tag} ==="
            echo "  Version: $version"
            echo "  Platforms: ${#refs[@]}"
            
            # List all platforms for this group
            for ref in "${refs[@]}"; do
              echo "    - $ref"
            done
            echo ""
            
            # Validate minimum platform count
            if [[ ${#refs[@]} -lt 2 ]]; then
              echo "  ⚠️  WARNING: Only ${#refs[@]} platform(s) found for ${provider}:${feature_tag}"
              echo "  Multi-platform manifests require at least 2 platforms"
              echo "  This indicates that some builds may have failed or artifacts are missing"
              echo "  Skipping manifest creation for ${provider}:${feature_tag}"
              echo ""
              continue
            fi
            
            # 1. Create version-pinned multi-platform manifest (e.g., 0.1.0-metal)
            versioned_tag="${base}:${version}-${feature_tag}"
            create_index "$versioned_tag" "${refs[@]}" || exit 1
            
            # 2. Create/update latest-{feature} tag (e.g., latest-metal)
            latest_feature_tag="${base}:latest-${feature_tag}"
            create_index "$latest_feature_tag" "${refs[@]}" || exit 1
            
            # 3. For "default" feature, also create plain version tag (e.g., 0.1.0)
            if [[ "$feature_tag" == "default" ]]; then
              plain_version_tag="${base}:${version}"
              create_index "$plain_version_tag" "${refs[@]}" || exit 1
            fi
            
            echo ""
          done

          # 4. Create plain "latest" tag for each provider (points to default features)
          echo "=== Creating 'latest' tags ==="
          for provider in "${!provider_versions[@]}"; do
            group_key="${provider}|default"
            if [[ -n "${groups[$group_key]:-}" ]]; then
              IFS=' ' read -ra refs <<< "${groups[$group_key]}"
              base="ghcr.io/${{ github.repository_owner }}/${provider}"
              latest_tag="${base}:latest"
              create_index "$latest_tag" "${refs[@]}" || exit 1
            else
              echo "  Skipping ${provider}:latest (no 'default' feature set found)"
            fi
          done

          echo ""
          echo "=== Summary ==="
          total_manifests=$((${#groups[@]} * 2))
          for group_key in "${!groups[@]}"; do
            IFS='|' read -r _ feature_tag <<< "$group_key"
            [[ "$feature_tag" == "default" ]] && ((total_manifests++))
          done
          # Count providers with default feature for latest tags
          for provider in "${!provider_versions[@]}"; do
            [[ -n "${groups[${provider}|default]:-}" ]] && ((total_manifests++))
          done
          echo "Created $total_manifests manifest indexes across ${#provider_versions[@]} provider(s)"

      - name: Validate multi-platform manifests
        shell: bash
        run: |
          #!/bin/bash
          set -euo pipefail
          
          echo "=== Validating multi-platform manifests ==="
          echo "Verifying that platform fields are properly set..."
          echo ""
          
          # Read all manifest data files to get list of tags to validate
          declare -A provider_features
          
          for data_file in manifests/*/data.txt; do
            [[ -f "$data_file" ]] || continue
            
            unset PROVIDER FEATURE_TAG
            source "$data_file"
            
            [[ "$PROVIDER" == "noop" ]] && continue
            
            key="${PROVIDER}|${FEATURE_TAG}"
            provider_features[$key]=1
          done
          
          if [[ ${#provider_features[@]} -eq 0 ]]; then
            echo "No manifests to validate, skipping"
            exit 0
          fi
          
          validation_failed=false
          
          # Validate each unique (provider, feature_tag) combination
          for key in "${!provider_features[@]}"; do
            IFS='|' read -r provider feature_tag <<< "$key"
            base="ghcr.io/${{ github.repository_owner }}/${provider}"
            tag="${base}:latest-${feature_tag}"
            
            echo "Validating: $tag"
            
            # Fetch the index
            index=$(oras manifest fetch "$tag" 2>&1)
            if [[ $? -ne 0 ]]; then
              echo "  ❌ ERROR: Failed to fetch manifest"
              validation_failed=true
              continue
            fi
            
            # Check if it's an index
            media_type=$(echo "$index" | jq -r '.mediaType // empty')
            if [[ "$media_type" != "application/vnd.oci.image.index.v1+json" ]]; then
              echo "  ⚠️  WARNING: Not an image index (mediaType: $media_type)"
              continue
            fi
            
            # Check each manifest descriptor for platform fields
            manifest_count=$(echo "$index" | jq '.manifests | length')
            echo "  Found $manifest_count platform(s)"
            
            platform_errors=0
            for i in $(seq 0 $((manifest_count - 1))); do
              os=$(echo "$index" | jq -r ".manifests[$i].platform.os // empty")
              arch=$(echo "$index" | jq -r ".manifests[$i].platform.architecture // empty")
              digest=$(echo "$index" | jq -r ".manifests[$i].digest")
              
              if [[ -z "$os" ]] || [[ -z "$arch" ]]; then
                echo "  ❌ ERROR: Manifest descriptor missing platform info"
                echo "     Digest: $digest"
                echo "     OS: '$os', Architecture: '$arch'"
                ((platform_errors++))
                validation_failed=true
              else
                echo "  ✓ Platform $os/$arch (${digest:0:19}...)"
              fi
            done
            
            if [[ $platform_errors -eq 0 ]]; then
              echo "  ✓ All platform fields validated successfully"
            fi
            echo ""
          done
          
          if [[ "$validation_failed" == "true" ]]; then
            echo "❌ Validation failed: Some manifests are missing platform information"
            exit 1
          fi
          
          echo "✅ All multi-platform manifests validated successfully"
